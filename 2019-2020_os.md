---
title: 2019-2020 Cours d'introduction aux syst√®mes d'exploitations, de la th√©orie √† la pratique
layout: default.liquid
---

# 2019-2020 - Cours d'introduction aux syst√®mes d'exploitations : de la th√©orie √† la pratique

Note: le cours sera mis √† jour au moins une fois par semaine ! Pensez √† le ret√©l√©charger ou √† le consulter sur le site <https://darnuria.eu/2019-2020_os>.

Bienvenue sur le site compagnon du cours d'introduction aux syst√®mes
d'exploitation, l'enjeu de ce cours est de faire le lien entre th√©orie et pratique.

Ce cours est en lien direct avec votre cours d'assembleur et votre cours de C
avec Fr√©d√©ric : les savoirs et pratiques que nous allons d√©velopper ensemble
seront plus facile √† acqu√©rir si vous suivez votre cours de C et d'assembleur,
et vice-versa. ;)

Liens utiles pour le cours¬†:

- [Notice encodages nombres](https://darnuria.eu/notice-encodage.html)
- [Rappels de langage C](https://darnuria.eu/langage-c-standard18.html)

## Contributions

- Auteur: Axel Viala

Contributions:

- Hadrien P√©lissier¬†: relecture et rephrasage cours 1
- Elie Gavoty¬†: relectures cours 1
- Jo√´lle Castelli¬†: typographie, corrections stylistiques
- Ma√´lle Ferre: signalement de liens morts et fautes d'orthographes

## Environnement de d√©veloppement pour le cours

Dans ce cours le syst√®me de r√©f√©rence sera la distribution [GNU](https://www.gnu.org/)/[Linux](https://en.wikipedia.org/wiki/Linux) [Ubuntu 18.04.03 LTS Bionic Beaver](http://releases.ubuntu.com/18.04/).
Si vous utilisez une autre distribution GNU/Linux aucun probl√®me, mais t√¢chez
d'avoir un syst√®me √† jour et utilisable en classe. ;)

### Mac OS X

Si vous utilisez Mac OS X vous pouvez suivre ce guide en anglais¬†:
<https://solarianprogrammer.com/2017/05/21/compiling-gcc-macos/>

Veillez √† bien avoir une version r√©cente de gcc telle que la version 7 ou 8.

### Windows sous syst√®me Linux

**Section en cours de construction**

Le tutoriel pour installer Windows Subsystem for Linux (WSL)¬†: <https://docs.microsoft.com/fr-fr/windows/wsl/install-win10>

## √âditeur de texte

Concernant l'√©diteur de r√©f√©rence, n'importe quel √©diteur (moderne) que vous
ma√Ætrisez devrait convenir. Id√©alement privil√©giez un √©diteur qui poss√®de
des fonctionnalit√©s pour naviguer dans le code et afficher les erreurs √† la
vol√©e.

Si vous ne savez pas quoi choisir vous pouvez prendre¬†:

- Emacs avec [Spacemacs](http://spacemacs.org/)
- Vim avec [Syntastic](//github.com/vim-syntastic/syntastic)
- [Neovim](https://neovim.io/)
- VSCode ou [VScodium](https://github.com/VSCodium/vscodium) (version communautaire
de VSCode sans la t√©l√©m√©trie).

A titre personnel j'utilise Spacemacs et VSCodium sur Ubuntu 18.04.03.

Je vais privil√©gier l'usage de logiciels libres et Open Source, car ce sont des
logiciels que vous pouvez aller √©tudier en lisant leur code.

Je vous proposerai d'ailleurs √† plusieurs moments du cours d'√©tudier le code de
plusieurs biblioth√®ques et logiciels libre proches du syst√®me.

## Compilateurs et langages

Nous d√©velopperons principalement en C avec le standard C18. Nous utiliserons le
compilateur [gcc](https://gcc.gnu.org/) en version 8.3 ou sup√©rieur, ou bien le compilateur [clang](https://clang.llvm.org/) en version 8 ou plus.

J'ai volontairement choisi d'utiliser des compilateurs modernes afin que vous
puissiez b√©n√©ficier d'erreurs de compilation compr√©hensibles.

### Autres langages

Pour vous faire d√©couvrir certains concepts avanc√©s tel que la concurrence, le
parall√©lisme et la programmation syst√®me moderne, il est possible
d'utiliser Rust, Go ou encore C++ moderne¬†: nous installerons ensemble
l'√©cosyst√®me.

## Plan du cours

Le plan n'est pas d√©finitif¬†: il est √† titre indicatif, tous les sujets
sont assez entrem√™l√©s. Il s'agit de grandes th√©matiques que nous allons aborder.

- Langage C
- appels syst√®me
- Programmation syst√®me
- D√©couverte des entr√©es-sorties
- M√©moire
- Syst√®me de fichier
- Processus
- Communication interprocessus
- R√©seau
- Introduction¬†: Rust ou C++

## Cours 1 et 2¬†: Introduction et appels syst√®me

Objectifs p√©dagogiques¬†:

- Rappels sur le langage C
- D√©couverte des appels syst√®me
- D√©couverte des outils d'inspection de binaires
- Vue d'ensemble du ¬´¬†syst√®me¬†¬ª

### C'est quoi un syst√®me¬†d'exploitation¬†?

Un [syst√®me d'exploitation](https://en.wikipedia.org/wiki/Operating_system)
est un concept g√©n√©ral pour d√©signer un ensemble de services
rendus √† des programmes. Ces services peuvent √™tre r√©alis√©s par des biblioth√®ques,
d'autres programmes ou bien directement par le kernel.

C'est un concept vaste, il existe plusieurs fa√ßon de r√©aliser un syst√®me d'exploitation.

### C'est quoi un noyau _kernel_ de syst√®me d'exploitation

Un noyau ou [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) de syst√®me d'exploitation est un programme g√©rant des ressources mat√©rielles et
logicielles ainsi que des op√©rations d'intercommunication entre ces ressources.
Il peut √™tre plus ou moins complexe.

Il existe plusieurs fa√ßons de r√©aliser un kernel. Linux par exemple est un kernel _monolithique_,
au sens o√π le kernel accomplit √©normement de fonctions. D'autres fa√ßons de faire existent¬†:
par exemple [XNU](https://en.wikipedia.org/wiki/XNU), la base du syst√®me d'exploitation Mac OS X, n'est pas
un design monolithique.

Ouvertures¬†: Des approches diff√©rentes existent. Le multi-kernel [barrelfish](http://www.barrelfish.org/), ou bien [almos-mkh](https://www-soc.lip6.fr/trac/almos-mkh/) tentent de concevoir des kernels pour les architectures avec plus
de 128 processeurs.

### C'est quoi un appel syst√®me¬†?

Un appel syst√®me est un service effectu√© par le kernel du syst√®me d'exploitation.
Lors d'un appel syst√®me, votre programme passe en mode kernel (_kernel-land_).
En simplifiant, temporairement votre programme n'ex√©cute plus son code mais celui du kernel pour r√©soudre cet appel syst√®me, par exemple *write* dans notre exercice ci-dessous. _Nous reviendrons sur cette notion au cours 3_.

En g√©n√©ral les appels syst√®me n√©cessitent de dialoguer avec le mat√©riel _hardware_,
ou de respecter des besoins de s√©curit√© avec ou sans support mat√©riel (par exemple
le dialogue interprocessus, le r√©seau, etc.).

### Comment r√©alise-t-on un appel syst√®me¬†?

Les appels syst√®me dans les syst√®mes modernes font appel √† une instruction sp√©cialis√©e souvent
nomm√©e _syscall_. Voici un panorama des instructions r√©alisant cette t√¢che sur plusieurs architectures:

- [x86_64](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)¬†: `syscall`
- [RISC-V](https://content.riscv.org/wp-content/uploads/2016/06/riscv-spec-v2.1.pdf)¬†: `ecall`
- [ARMv8](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0179b/ar01s02s07.html)¬†: `SVC`

Vous ne verrez pas souvent cette instruction dans vos programmes en C car les appels syscalls sont souvent r√©alis√©s par des biblioth√®ques syst√®me pour vous telles que la [libc](https://en.wikipedia.org/wiki/C_standard_library). Sous Linux, en g√©n√©ral vous utilisez la [glibc](https://www.gnu.org/software/libc/).

_Note_ `x86_64`¬†: vous avez peut-√™tre vu ou utilis√© `sysenter`, ou bien `int 0x80`. Ce sont des fa√ßons d'appeler un syscall pour x86_64 en mode 32bits. Pour information, `int 0x80` est consid√©r√©e comme d√©pr√©ci√©e.

Dans le TP nous allons voir comment r√©aliser cet appel syst√®me en C et, pour aller plus loin en assembleur, sans C.

### TP: Write `"Hello, World!"`

Nous allons r√©aliser un petit programme C et l'analyser.

Objectifs:

- Revoir comment compiler un programme en C avec des warnings
- Revoir les bases de C
- Analyser basiquement un binaire compil√© avec `objdump`, `hexdump`
- D√©couvrir les abstractions syst√®me par la pratique
- D√©couvrir l'appel syst√®me `write`
- Tracer les appels syst√®me `strace`

Les commandes d'analyse vous seront utiles en cours de s√©curit√©. ;)

#### Installation du compilateur GCC-8

Si ce n'est pas d√©j√† fait nous allons installer un compilateur C √† jour :

```bash
$ sudo apt install gcc-8 # gcc-8 est le programme que nous voulons installer
# ^    ^   ^             # C'est aussi un argument de ligne de commande.
# |    |   \ est un argument de la commande `apt`
# |    \ apt est une commande qui permet de g√©rer vos paquets.
# \ sudo demande les droits du super utilisateur pour installer un paquet.

# Si tout va bien vous deviez voir le message suivant s'afficher
$ gcc-8 --version
gcc-8 (Ubuntu 8.3.0-6ubuntu1~18.04.1) 8.3.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

Note: vous verrez le caract√®re `$` dans les exemples de ligne de commande que
je vous donne. C'est pour indiquer que c'est une commande √† saisir dans votre
shell [bash](https://www.gnu.org/software/bash/) ou [zsh](https://www.zsh.org/https://www.zsh.org/).

Une fois **gcc-8** install√© nous allons √©crire le programme C suivant¬†:

```c
// Headers de la biblioth√®que standard unistd, vous pouvez les retrouver
// sur ubuntu ici: `/usr/include/unistd.h`
#include <unistd.h>

/*
 * Questions¬†:
 * - R√©ussir √† faire fonctionner ce programme pour qu'il affiche la chaine msg.
 * - Que fait l'appel syst√®me write¬†?
 * - Comment tracer/lister des appels syst√®me sur un programme¬†?
 */
int main(void) {
  const char msg[] = "Hello, world!";
  // msg est une chaine qui sera stock√©e dans le
  // segment de donn√©es de votre programme.
  write(???, ???, ???);
  // \ les arguments sont √† corriger, le programme ne compile pas actuellement.
  return 0;
}
```

Je vous invite √† consulter le manuel (commande `man`) de l'appel syst√®me `write`.

Vous pouvez compiler ce programme avec la commande suivante¬†:

```bash
$ gcc-8 -Wall -Wextra ex0_write.c
# Cette commande produit l'ex√©cutable `a.out`
# que vous pouvez ex√©cuter comme cela :
$ ./a.out
```

#### Un appel syst√®me ¬´√† la main¬ª sur l'architecture `x86_64`

Une fa√ßon de faire sans le langage C, ni libc, aurait √©t√© d'√©crire le programme
en assembleur x86_64 suivant¬†:

```asm
; hello.s
global _start

section .text

_start:

; num√©ro d'appel syst√®me
; write est l'appel syst√®me num√©ro 1
; C'est Linux (et POSIX) qui a d√©fini cette convention
; que nous devons respecter pour faire un write.

; STDOUT == 1
; La sortie standard STDOUT est le file descriptor 1
; c'est une convention impos√©e par POSIX et respect√©e par Linux.

mov rax, 1      ; write(
mov rdi, 1      ;   STDOUT_FILENO,
mov rsi, msg    ;   "Hello, world!\n",
mov rdx, msglen ;   sizeof("Hello, world!\n")
syscall         ; );

mov rax, 60     ; exit(
mov rdi, 0      ;   EXIT_SUCCESS
syscall         ; );

section .rodata
msg: db "Hello, world!", 10
msglen: equ $ - msg
```

Et de l'assembler et de le lier (le _linker_) avec les commandes ci-dessous¬†:

```shell
$ nasm -f elf64 -o hello.o hello.s
$ ld -o hello hello.o
$ ./hello
Hello, world!
```

Si vous voulez en savoir plus sur ma source, il s'agit d'un billet de blog
[Hello world in Linux x86-64 assembly](https://jameshfisher.com/2018/03/10/linux-assembly-hello-world/) sur le blog de [Jim Fisher](https://jameshfisher.com/).

###  Analyses

#### Observation d'un fichier compil√© - objdump

Une fois ce code fonctionnel nous pouvons l'analyser.

Pour ce faire nous allons commencer par observer la structure de
l'ex√©cutable produit √† l'aide de la commande¬†:

```bash
# Le param√®tre -S est pour entrem√™ler source et asm.
$ objdump -S a.out | less
```

```txt
0000000000000685 <main>:
 685:   55                      push   %rbp
 686:   48 89 e5                mov    %rsp,%rbp
 689:   48 83 ec 20             sub    $0x20,%rsp
 68d:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
 694:   00 00
 696:   48 89 45 f8             mov    %rax,-0x8(%rbp)
 69a:   31 c0                   xor    %eax,%eax
 69c:   48 b8 48 65 6c 6c 6f    movabs $0x77202c6f6c6c6548,%rax
 6a3:   2c 20 77
 6a6:   48 89 45 ea             mov    %rax,-0x16(%rbp)
 6aa:   c7 45 f2 6f 72 6c 64    movl   $0x646c726f,-0xe(%rbp)
 6b1:   66 c7 45 f6 21 00       movw   $0x21,-0xa(%rbp)
 6b7:   48 8d 45 ea             lea    -0x16(%rbp),%rax
 6bb:   ba 0e 00 00 00          mov    $0xe,%edx
 6c0:   48 89 c6                mov    %rax,%rsi
 6c3:   bf 01 00 00 00          mov    $0x1,%edi
 6c8:   e8 a3 fe ff ff          callq  570 <write@plt>
 6cd:   b8 00 00 00 00          mov    $0x0,%eax
 6d2:   48 8b 4d f8             mov    -0x8(%rbp),%rcx
 6d6:   64 48 33 0c 25 28 00    xor    %fs:0x28,%rcx
 6dd:   00 00
 6df:   74 05                   je     6e6 <main+0x61>
 6e1:   e8 9a fe ff ff          callq  580 <__stack_chk_fail@plt>
 6e6:   c9                      leaveq
 6e7:   c3                      retq
 6e8:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
 6ef:   00
```

_Note_: vous pouvez avoir un dump plus int√©rressant en compilant avec l'option `-g` qui exporte
des informations utiles.

Voici le code en assembleur [x86_64](https://en.wikipedia.org/wiki/X86-64) de votre fonction `main`.

O√π est notre appel √† `write`? Indice : vous pouvez faire une
recherche avec la commande`grep` ou avec `/` dans `less`.

#### Ficher vu en hexad√©cimal - hexdump

A pr√©sent on va observer notre fichier en vue hexad√©cimale pour rechercher notre cha√Æne
de caract√®res `"Hello, world!"`.

Vous devriez obtenir quelque chose comme cela¬†: il s'agit d'une vue en
hexad√©cimal de votre programme, pour √™tre pr√©cis, aux alentours de l√† o√π
la cha√Æne `msg` est stock√©e.

La commande `hexdump -C ficher_a_dump` se lit de la fa√ßon suivante¬†:
num√©ro de _ligne_, 64 bits de donn√©es ou 16 bytes (octets), leur
repr√©sentation en caract√®res.

```
00000700  20 00 55 48 8d 2d ae 06  20 00 53 41 89 fd 49 89  | .UH.-.. .SA..I.|
00000710  f6 4c 29 e5 48 83 ec 08  48 c1 fd 03 e8 27 fe ff  |.L).H...H....'..|
00000720  ff 48 85 ed 74 20 31 db  0f 1f 84 00 00 00 00 00  |.H..t 1.........|
00000730  4c 89 fa 4c 89 f6 44 89  ef 41 ff 14 dc 48 83 c3  |L..L..D..A...H..|
00000740  01 48 39 dd 75 ea 48 83  c4 08 5b 5d 41 5c 41 5d  |.H9.u.H...[]A\A]|
00000750  41 5e 41 5f c3 90 66 2e  0f 1f 84 00 00 00 00 00  |A^A_..f.........|
00000760  f3 c3 00 00 48 83 ec 08  48 83 c4 08 c3 00 00 00  |....H...H.......|
00000770  01 00 02 00 48 65 6c 6c  6f 2c 20 77 6f 72 6c 64  |....Hello, world|
00000780  21 00 00 00 01 1b 03 3b  38 00 00 00 06 00 00 00  |!......;8.......|
00000790  dc fd ff ff 84 00 00 00  0c fe ff ff ac 00 00 00  |................|
000007a0  1c fe ff ff c4 00 00 00  7c fe ff ff 54 00 00 00  |........|...T...|
000007b0  6c ff ff ff dc 00 00 00  dc ff ff ff 24 01 00 00  |l...........$...|
```

Note: votre hexdump peut diff√©rer selon vos options de compilation.

#### Analyse des appels syst√®me - strace

[strace](https://strace.io/) est un logiciel permettant de suivre et observer
des appels syst√®me sur un programme donn√© en param√®tre.

Si vous devez debugger des appels syst√®me c'est un outil tr√®s puissant.

_Note_: C'est un outil utile pour les challenges de s√©curit√© orient√©s syst√®me¬†! ;)

Par exemple voici la ¬´trace¬ª de notre programme obtenue avec¬†: `$ strace ./a.out > log`.

```
execve("./a.out", ["./a.out"], 0x7ffd9e7b3190 /* 74 vars */) = 0
brk(NULL)                               = 0x559cc2ee0000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/tls/haswell/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/tls/haswell/x86_64", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/tls/haswell/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/tls/haswell", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/tls/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/tls/x86_64", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/tls/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/tls", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/haswell/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/haswell/x86_64", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/haswell/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/haswell", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib/x86_64", 0x7ffe99a92ba0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/home/darnuria/.local/lib/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
stat("/home/darnuria/.local/lib", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
openat(AT_FDCWD, "tls/haswell/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "tls/haswell/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "tls/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "tls/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "haswell/x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "haswell/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "x86_64/libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "libc.so.6", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=123633, ...}) = 0
mmap(NULL, 123633, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa8fbe6b000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa8fbe69000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa8fb872000
mprotect(0x7fa8fba59000, 2097152, PROT_NONE) = 0
mmap(0x7fa8fbc59000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fa8fbc59000
mmap(0x7fa8fbc5f000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa8fbc5f000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7fa8fbe6a4c0) = 0
mprotect(0x7fa8fbc59000, 16384, PROT_READ) = 0
mprotect(0x559cc1eff000, 4096, PROT_READ) = 0
mprotect(0x7fa8fbe8a000, 4096, PROT_READ) = 0
munmap(0x7fa8fbe6b000, 123633)          = 0
write(1, "Hello, world!\0", 14)         = 14
exit_group(0)                           = ?
+++ exited with 0 +++
```

On voit √† la fin notre `write` avec les arguments que nous lui avons donn√©¬†! Le reste est introduit par notre
shell (bash ici) et la libc pour diverses raisons.

A titre de comparaison voici un strace de notre version ¬´√† la main¬ª `strace ./hello > log`:

```txt
execve("./write", ["./write"], 0x7ffce51e2390 /* 74 vars */) = 0
write(1, "Hello, world!\n", 14)         = 14
exit(0)                                 = ?
+++ exited with 0 +++
```

Aucune des deux versions est meilleure¬†: si les appels syst√®me sont pr√©sent dans la version en C c'est souvent pour
des raisons de praticit√©, comptatibilit√© ou de s√©curit√©.


### Exercice 01: Travail √† la maison - filedex

Dans ce travail √† la maison je vous invite √† r√©aliser un programme en C
qui affiche des informations sur des fichiers.

*Objectifs*:

- *Apprendre √† lire* et *rechercher* de la documentation technique en *autonomie*
- Documenter ligne √† ligne votre programme pour expliquer son fonctionnement
- Revoir comment compiler un programme en C
- Bases sur les Structures en C
- D√©couverte de `stat` et optionnellement `open` et `fstat`
- Manipulation avanc√©e de `printf`

*Difficult√©s*:

- Manipulation de structures
- Lecture de la documentation man
- Utilisation de `stat`, optionnellement `fstat` et `open`

*Notation*:

- 33% r√©alisation, 33% documentation, 33% questions

Temps de travail estim√©: 3h √† 4h lectures et questions incluses.

Ce programme devra afficher sur la sortie standard les informations sur un fichier, notament sa taille,
son type et ses droits d'acc√®s, le chemin _path_ du fichier sera donn√© en param√®tre √† votre programme.

Pour compiler ce fichier vous pourrez faire: `gcc -Wall -Werror -Wextra filedex.c`.

Et son usage sera le suivant¬†:

```
# Sans arguments
$ ./a.out
Usage: ./a.out <pathname>
# Avec un argument qui est un chemin de fichier
$ ./a.out a.out
File type:                regular file
I-node number:            13268379
Mode:                     100755 (octal)
Link count:               1
Ownership:                UID=1000   GID=1000
Preferred I/O block size: 4096 bytes
File size:                12744 bytes
Blocks allocated:         32
Last status change:       Mon Oct  7 16:50:11 2019
Last file access:         Mon Oct  7 16:50:13 2019
Last file modification:   Mon Oct  7 16:50:11 2019
```

Pour se simplifier la vie on ne g√®re pas les erreurs dans ce travail pratique.

Pour ce faire vous devrez utiliser et manipuler l'appel syst√®me `fstat`, pour obtenir
des metadonn√©es de fichier, utiliser `open` pour obtenir un descripteur de fichier et
utiliser `printf` pour formater et afficher ces informations.

Votre documentation principale sera [`man 2 fstat`](https://linux.die.net/man/2/fstat), surtout la section: `EXAMPLE`.

Je vous invite tr√®s fortement √† commencer avec l'exemple issu du manuel de `fstat`.

Attention¬†: par mesure de s√©curit√© et de prudence, n'ex√©cutez jamais, sauf indication contradictoire, en `sudo` ou `root` les
programmes de ce cours. Un mauvais usage des appels syst√®me peut parfois causer des soucis.

#### Questions

Une fois ce programme r√©alis√©, je vous demande d'expliquer ligne √† ligne votre programme,
quels concepts de C vous manipulez, quels appels syst√®me vous r√©alisez et ce que repr√©sentent
les informations que vous allez afficher. Vous pouvez rester succincts mais l'objectif est
de retranscrire votre travail de recherche documentaire.

En plus veuillez r√©pondre aux questions suivantes en commentaire en haut de votre programme¬†:

- Dans ce programme combien de fois au moins entre-t-on volontairement en mode syst√®me?
(Indice: utilisez strace pour compter¬†! ;))
- Tous les fichiers d'un syst√®me Unix (Linux/OSX) sont-ils du stockage de donn√©es sur un
disque¬†? Si non donnez deux autres exemples.
- Optionnel: Quelle est l'addresse (pointeur) de d√©but de la section des arguments d'un programme¬†?
Elle peut varier un peu a cause d'une technique nomm√©e distribution al√©atoire de l'espace d'adressage,
[ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization)¬†;
- Bonus (dur): Sous Linux qui alloue l'espace des arguments et de l'environnement d'un programme
pour vous et comment? (indice: utilisez strace)
- Bonus (dur): r√©ecrire votre programme pour utiliser `open` et `fstat` au lieu de `stat`.


#### Bonus

Vous pouvez compiler avec plusieurs niveaux d'optimisations
options `-O0`, `-O1`, `-O2`, `-O3` et constater des
changements dans le code emit.

## Corrections

### Exercice 01 - stat

Voir [Rappels de langage C sur les structs](https://darnuria.eu/langage-c-standard18#struct).

Voici le code source comment√© ligne √† ligne de `filedex`, vous pouvez trouver
un point de d√©part pour r√©soudre l'exercice dans le manuel de l'appel `man 2 stat`.

```c
// Programme comment√© inspir√© du manuel de l'appel syst√®me stat.
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sysmacros.h>

int main(int argc, char *argv[]) {

  // On quitte si on √† pas 2 arguments
  // (par defaut argv contient le nom du programme en argument 0)
  if (argc != 2) {
    // On affiche un message d'erreur pour expliquer le probl√®me rencontr√©.
    fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
    // On signale une erreur au processus parent.
    exit(EXIT_FAILURE);
  }

  // On alloue dans la *pile* une structure de type `struct stat`
  struct stat sb;
  // On realise notre appel syst√®me ici lstat qui va remplir la structure
  // sb si tout se passe bien.
  // Le passage est par pointeur.
  const int ret = lstat(argv[1], &sb);

  // Si lstat echoue ret vaut -1
  if (ret == -1) {
    perror("lstat");
    exit(EXIT_FAILURE);
  }

  // On affiche des informations renvoy√©es par lstat
  // parfois des *cast* ou changements de types sont neccessaires.
  // Aussi parfois on a besoin de macro d√©finies definies dans sysmacro
  // pour obtenir la partie pertinante d'un entier a affichier.
  printf("ID of containing device:  [%lx,%lx]\n",
      (long) major(sb.st_dev), (long) minor(sb.st_dev));

  printf("File type:                ");

  switch (sb.st_mode & S_IFMT) {
  case S_IFBLK:  printf("block device\n");            break;
  case S_IFCHR:  printf("character device\n");        break;
  case S_IFDIR:  printf("directory\n");               break;
  case S_IFIFO:  printf("FIFO/pipe\n");               break;
  case S_IFLNK:  printf("symlink\n");                 break;
  case S_IFREG:  printf("regular file\n");            break;
  case S_IFSOCK: printf("socket\n");                  break;
  default:       printf("unknown?\n");                break;
  }

  printf("I-node number:            %ld\n", (long) sb.st_ino);

  printf("Mode:                     %lo (octal)\n",
          (unsigned long) sb.st_mode);

  printf("Link count:               %ld\n", (long) sb.st_nlink);
  printf("Ownership:                UID=%ld   GID=%ld\n",
          (long) sb.st_uid, (long) sb.st_gid);

  printf("Preferred I/O block size: %ld bytes\n",
          (long) sb.st_blksize);
  printf("File size:                %lld bytes\n",
          (long long) sb.st_size);
  printf("Blocks allocated:         %lld\n",
          (long long) sb.st_blocks);

  printf("Last status change:       %s", ctime(&sb.st_ctime));
  printf("Last file access:         %s", ctime(&sb.st_atime));
  printf("Last file modification:   %s", ctime(&sb.st_mtime));

  // On signale au parent que tout s'est bien pass√©.
  exit(EXIT_SUCCESS);
}
```

### Concept UNIX: ¬´Tout est fichier¬ª

#### C'est quoi un fichier

Un ¬´¬†fichier¬†¬ª ou _file_ en anglais est une fa√ßon de conceptualiser
une donn√©e sur un ordinateur. Un fichier est associ√© √† un nom de fichier _filename_,
et √† un chemin d'acc√®s absolu depuis une origine. Sur UNIX cette origine c'est `/`,
par exemple `cat.jpg` dans votre home serait au chemin: `/home/axel/cat.jpg`.

Cette arborescence simplif√©e pour aller jusque √† `cat.jpg` donne quelque chose comme √ßa¬†:

```bash
/
‚îú‚îÄ‚îÄ bin    # Binaires du syst√®me
‚îú‚îÄ‚îÄ boot   # Contient le kernel et le bootloader
‚îú‚îÄ‚îÄ cdrom  # Legacy? ;)
‚îú‚îÄ‚îÄ dev    # Contient les devices / periph√©riques
‚îú‚îÄ‚îÄ etc    # Les configurations
‚îú‚îÄ‚îÄ home   # Dossier home des utilisateurs
‚îÇ   ‚îî‚îÄ‚îÄ axel
‚îÇ       ‚îî‚îÄ‚îÄ cat.jpg
‚îú‚îÄ‚îÄ lib    # Biblioth√®ques et plus
‚îú‚îÄ‚îÄ lib32  # Biblioth√®ques compil√©es 32bits
‚îú‚îÄ‚îÄ lib64  # Biblioth√®ques compil√©es 64bits
‚îú‚îÄ‚îÄ lost+found
‚îú‚îÄ‚îÄ media  # Point de montages des supports amovibles
‚îú‚îÄ‚îÄ mnt
‚îú‚îÄ‚îÄ opt
‚îú‚îÄ‚îÄ proc   # Informations sur les processus execut√©es
‚îú‚îÄ‚îÄ root   # Home du super utilisateur
‚îú‚îÄ‚îÄ run
‚îú‚îÄ‚îÄ sbin
‚îú‚îÄ‚îÄ srv
‚îú‚îÄ‚îÄ sys    # Informations du kernel expos√©es aux programmes
‚îú‚îÄ‚îÄ tmp    # Contient des donn√©es temporaires
‚îú‚îÄ‚îÄ usr    # UNIX System Resources - config et plus des programmes
‚îî‚îÄ‚îÄ var
```

Un fichier peut repr√©senter une donn√©e qui existe sur votre support de stockage,
Solid state disk SSD ou Hard Disk Drive HDD, mais nous verrons plus loin que
√ßa peut repr√©senter bien plus.

C'est √† la fois une fa√ßon d'organiser l'information (des donn√©es) accessibles sur
un ordinateur par un humain mais aussi une interface entre programmes et le kernel.

_NOTE_: Sous Windows il existe plusieurs racines, une par disque, `C:`, `D:`
et les chemins sont s√©par√©s par des `\`.

### Et le Tout-fichier : pourquoi¬†?

Le syst√®me que nous utilisons pour pratiquer est Ubuntu 18.04.03,
il s'agit d'un syst√®me d'exploitation de la famille des ¬´UNIX¬ª,
son _kernel_, en fran√ßais noyau, s'appelle Linux. Vous verrez parfois GNU/Linux,
GNU est la suite de logiciel et biblioth√®ques n√©cessaires pour exploiter un noyau.

Unix est une famille de syst√®mes d'exploitations connus pour proposer
une approche o√π toutes les ressources sont utilisables via une interface de
fichier, tr√®s peu d'appels syst√®me d√©rogent √† cette m√©thode.

Sous UNIX vous voulez √©crire sur la console¬†? Vous utiliserez le m√™me appel syst√®me
que pour √©crire dans un fichier: `write` [man 2 write](https://linux.die.net/man/2/write), pour lire il existe `read` [man 2 read](https://linux.die.net/man/2/read).

Pour aller plus loin:

- _`printf` utilise dans son code `write`_
- _`fscanf` utilise au final `read`_

Vos programmes sont connect√©s √† 3 flux d'entr√©e sorties:

- `STDIN`: Entr√©e standard pour passer des informations pour que le programme travail
- `STDOUT`: Sortie standard pour l'affichage g√©n√©ral ou le resultat du programme
- `STDERR`: Sortie d'erreur on √©cris les messages erreurs sur ce canal.

Ces trois flux se comportent comme des fichiers un peu sp√©ciaux et sont tr√®s utilis√©s quand
vous travaillez avec un terminal. On vera avec la communication interprocessus que ces
trois flux sont tr√®s utilles

Pour communiquer entre deux programmes il existe des m√©canismes reposant aussi sur
une _Application Programming Interface_ (API) reposant sur le concept de fichier.

Pour acc√©der aux informations d'un processus¬†? C'est aussi par une API fichier.
Regardez le contenu du chemin: `/proc/<processus_id>/` il y a plein d'informations
relatives √† un processus en ex√©cution.

Bref sous Linux, comme sous MacOSX qui est aussi un Unix ¬´Tout est fichier¬ª,
sur Windows c'est une autre fa√ßon de concevoir (autre paradigme).

## Introduction sur la m√©moire

Sur un ordinateur moderne, la m√©moire joue un r√¥le centrale.

Elle remplis plusieurs missions:

- Sert de canal de communication avec le hardware
- De support pour les r√©sultats de calculs de nos programmes
- De canal de communication entres fils de calcul _threads_ ou processus.

Mat√©riellement la m√©moire est tr√®s souvent sous la forme de ¬´barrettes¬ª de m√©moire
contenant des banques de m√©moire d'une taille sur un multiple de 2 par exemples en 4 banques de 256 Mo
ce qui donne 1Go.

### Addressage

Cette m√©moire est addressable (accessible) par une unit√© minimale appell√©e byte, en g√©n√©ral un
byte est √©gal √† 8bits soit un octet, cependant historiquement il a exister des machines avec des bytes
de 10bits. La taille d'acc√®s la plus rapide est appell√©e le mot m√©moire ou *word*, par exemple:
Un processeur RiscV 32bits mips32 poss√®de des bytes de 8bits et il est possible d'addresser sur 8bits, 16bits ou 32bits.

Le processeur et les autres p√©riph√©riques y acc√®de par le biais d'un canal de communication mat√©riel
arbitr√© nomm√©e un bus, ici le bus m√©moire. Si cette notion vous int√©rresse je vous invite √† lire sur
l'architecture des ordinateurs.

Vous avez du le remarquer dans vos programmes vous g√©riez votre m√©moire comme si vos processus (voir chapitre suivant) √©taient
seuls sur l'ordinateur. Tout ce qui compte est d'avoir des adresses sur la m√©moire pour √©crire ou lire des valeurs.

Lien avec le C: Historiquement les types `char`, `short`, `int`, `long` derivent d'une volont√© de supporter toutes
les architectures possibles, beaucoup de ces architectures √©soth√©riques ont disparu car leurs particularit√©s n'√©taient pas
si pertinantes.

### M√©moire virtuelle

En effet de nos jours vous compilez vos programmes pour des adresses dites ¬´virtuelles¬ª, chaque processus peut
avoir les m√™mes adresse c'est le mat√©riel via un composant nomm√©e la MMU (M√©mory Management Unit) et le
gestionnaire de m√©moire virtuelle (VMM) de votre syst√®me d'exploitation.
Qu'une traduction vers des adresses physiques correspondants √† des emplacements
dans les banques de m√©moire de vos barrettes de m√©moire √† lieu.

Quel rapport avec nos programmes en C? On peut compiler pour un ordinateur sans se soucier de l'occupation
r√©el de la m√©moire dans une certaine mesure. Nos programmes peuvent √™tre interrompus si ils accedent √† de la m√©moire
non allou√©e bref c'est tr√®s pratique on reviendra dessus lors que l'ont parlera de m√©moire plus en d√©tail.

Pour √™tre pr√©cis nos syst√®mes modernes g√©rent la m√©moire virtuelle de fa√ßon pagin√©e et segment√©,
c'est √† dire la m√©moire est d√©coup√©e en bloc de taille fixe ici 1Kio et on regroupe ses blocs en segments avec un
sens, par exemple la pile `.stack`, le code `.text` ou le `.tas`.

Nos processus peuvent exploiter la m√©moire dans ces conditions sur un segment de 4Gb sur un processeur 32bits
et 8TB sur un processeur 64bits, le ¬´layout¬ª d'un processus (imagions un programme C) ressemble √† √ßa du point de vue des segments:

```txt
4GB (32bits /8TB (64bits)
üëá
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   stack   ‚îÇ <- Contexte de main(), parametres en ligne de commande argc/argv  
‚îÇ           ‚îÇ    appels de fonctions, croit vers le bas
‚îú ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚î§
‚îÇ     ‚¨á     ‚îÇ <- Espace non allou√©e
‚îÇ           ‚îÇ
‚îÇ           ‚îÇ
‚îÇ           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   data    ‚îÇ <- Donn√©es statiques, chaines et tableaux constants
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   text    ‚îÇ <- Instructions; code compil√©e (en lecture seul)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üëÜ 0
```

Si vous utilisez `malloc`, il peut resembler √† √ßa
```txt
4GB (32bits /8TB (64bits)
üëá
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   stack   ‚îÇ <- Contexte de main(), parametres en ligne de commande argc/argv  
‚îÇ           ‚îÇ    appels de fonctions, croit vers le bas
‚îú ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚î§
‚îÇ     ‚¨á     ‚îÇ <- Espace non allou√©e
‚îÇ           ‚îÇ
‚îÇ           ‚îÇ
‚îÇ     ‚¨Ü     ‚îÇ
‚îú ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚î§
‚îÇ   heap    ‚îÇ <- Espace allou√©e par malloc() croit vers le haut.
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   data    ‚îÇ <- Donn√©es statiques, chaines et tableaux constants
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   text    ‚îÇ <- Instructions; code compil√©e (en lecture seul)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üëÜ 0
```

Schemas librement inspir√©es de [stackExchange: Unix & Linux](https://unix.stackexchange.com/questions/250163/creation-of-the-heap-region-segment-in-linux).

## Processus - gestion des ressources

NOTE: En construction

Sur un ordinateur, si vous voulez avoir plusieurs taches, il y a plusieurs fa√ßon de faire
historiquement plusieurs approches ont √©t√© prises: Faire que toute les taches coop√©erents,
c'est tr√®s utilis√© en embarqu√© (IoT) mais sur vos machines on pr√©f√©re utiliser un model
preemptif ou ajouter un acteur ne neccessite pas d'informer tout les autres.

Le concept de processus que nous allons √©tudier est dans cette lign√©e,
par d√©faut un processus ignore qu'il fonctionnent sur un ordinateur avec d'autres processus.
Ce concept repr√©sente une ou plusieurs fils de calcul pour realiser une tache agisant ensemble,
en utilisant des ressources sur un ordinateur.

Un processus par d√©faut √† l'illusion d'avoir l'ordinateur pour lui seul,
le syst√®me d'exploitation propose cette abstraction pour lui. Par exemple:
vous demandez de la m√©moire on vous r√©ponds oui ou non mais
vous n'avez pas √† demander aux autres programmes pour en avoir.

Les ressources d'un processus sont par d√©faut priv√©e √† lui, un autre processus n'est
pas en mesure sauf partage d'avoir acc√®s aux donn√©es d'un autre.
On vera qu'il existe diverses exceptions ou m√©thodologies pour partager.

Vos processus dit utilisateurs ont peu de droits sur le mat√©riel.
Si on devait donner un diagramme des codes les plus privil√®gi√©es
aux moins privil√©gi√©e une version simple serait:
`Kernel > Processus de l'administrateur (sudo) > processus utilisateurs`

Le r√©sum√©:

Un processus poss√®de par d√©faut :

- Son espace m√©moire: donn√©es, code, etc (*segments* vu au chapitre pr√©c√©dents!)
- Possiblement de la m√©moire allou√©e dynamiquement si `malloc` √† √©t√© utilis√©
- Ses descripteurs de fichiers
- Ses fils de calculs (threads)

Partage avec:

- ses parents et enfants certaines ressources
- avec ses fils de calcul
- avec les autres processus seulement si des moyens de communications sont ouverts.

Un processus doit demander au syst√®me pour:

- ouvrir un fichier: `open`
- √©crire ou lire un fichier `write`, `read`
- obtenir plus de m√©moire `malloc` et `mmap`
- √©changer avec un autre processus *sockets*, *pipes*, *queue*, m√©moire partag√©e, etc.

Pour faire le lien avec notre cours pr√©c√©dent, plusieurs ressources sont acc√®ssibles, simplement
avec `open`, `write`, `read` d'autres utilisent un appel syst√®me d√©di√©e. C'est un choix de r√©alisation
pris par les personnes develloppant un noyau de syst√®me d'exploitaton.

### Cr√©ation

Si vous souhaitez cr√©er un nouveau processus la mani√®re de faire sous unix est via la
fonction [fork](doc!!), sous linux l'appel syst√®me est [clone](doc!!) cependant
nous utiliseront `fork` car `clone` est un appel syst√®me assez complexe √† maitriser.

-> Fork
concept du processus etc

_Note:_ En informatique vous verrez souvent le mot ¬´paradigme¬ª, ce mot sert √†
d√©signer une fa√ßon de structurer, concevoir les choses.

### Exercice sur les processus

#### Cr√©ation, √©xecution: ¬µshell

Objectifs:

- D√©couvrir la cr√©ation de procesuss
- La relation entre parent et enfant
- Attente entre processus
- Executer un programme

Dans ce tp nous allons partir du programme minimal suivant:

```c
#include <unistd.h> // fork, getppid, getpid
#include <stdio.h>  // printf
#include <sys/types.h> // pid_t etc

int main(void) {
  // /!\ Apr√®s cette ligne notre programme s'execute dans 2 procesuss diff√©rents. /!\
  pid_t fork_data = fork();
  // On r√©cup√©re le process identifier de l'enfant et du parent.
  pid_t pid = getpid();
  // On r√©cup√©re le pid du parent.
  pid_t ppid = getppid();
  if (fork_data > 0) {
    printf(
    "Je suis la maman chat,
    "mon pid est: %i, celui de mon chaton est: %i,"
    "celui de mon parent %i\n", pid, fork_data, ppid
    );
  } else if (fork_data == 0) {
    printf("Je suis le chaton, mon pid est: %i, celui de ma maman chat est: %i\n", pid, ppid);
  } else {
    perror("Quelque chose d'imprevu est arriv√©, fork impossible.");
  }
  return EXIT_SUCCESS;
}
```

### Questions

Que se passe t'il si le parent s'arr√™te avant le `printf` de son enfant? Quel sera la valeur de `ppid`,
comment corriger pour que le parent attendent la fin de son enfant? indice: `waitpid`.

Maintenant, que le parent attend bien son enfant, on souhaite executer le programme (compil√©) suivant dans l'enfant:

```c
// hi.c
// executable hi:
// Compiler avec gcc -Wall -Wextra hi.c -o hi
#include <stdio.h>
void main(void) {
  puts("Hello I am an awesome process");
}
```

Pour ce faire on peut utiliser `execve` qui permet d'executer une image m√©moire (votre executable), en lui donnant
ses arguments et son environnement. Inspirez vous des exemples du manuel `man 2 execve` pour √©crire ce mini-programme.

Pour ne pas avoir √† g√©rer le path, commencez par √©crire en dur dans votre `microShell`, le path du programme `hi` ci dessus.

√âtapes bonus:

- G√©rer le passage du programme par argument en ligne de commande avec `argv`
- G√©rer la transformation de la commande en path exemple: `./hi`
- G√©rer la recherche dans les variables d'environnement `man 3 getenv`, `man 7 environ`.
- G√©rer la saisie basique d'un nom de programme depuis l'entr√©e standard `STDIN`

√Ä l'issu de ses deux √©tapes bonus f√©licitation vous avez un micro-shell!

<!-- TODO: Schema -->

## Exercices en plus

### Commandes shell utiles sur les fichiers

A ce titre sur Linux ou MacOSX il existe quelques commandes tr√®s pratiques pour
manipuler des fichiers voici une liste non exhaustive que nous utiliseront
souvent.

#### cd : Changement de dossier de travail courant

La commande `cd` [cd]() permet de changer de dossier de travail courant _(cwd: current
    working directory)_ donc de vous d√©placer dans vos dossiers.

L'appel syst√®me indispensable pour que cette commande fonctionne est `chdir` ou
bien `fchdir`. `chdir manipule un chemin _path_, `fchdir` directement un
descripteur de fichier.

```c
// Extrait du man 2 chdir
#include <unistd.h>

int chdir(const char *path);
int fchdir(int fd);
```

##### Exercice : Personnal teleporter

*Difficult√©:* Facile
*Temps estim√©:* 1h √† 2h.

*Objectif:*

- Familiarisation avec les chemins paths
- D√©couverte des arguments de ligne de commande
- Programmation Unix basique
- Optionnel: Familiarisation avec les descripteurs de fichiers

*Concepts de C neccessaires:*

- fonctions
- pointeurs
- array (tableaux)
- appel de fonctions
- documenter son code

L'objectif de ce tp est d'√©crire un programme qui permet de se t√©l√©porter dans
votre syst√®me si on lui donne un chemin valide en argument.

Il ne s'agit absolument pas d'une p√¢le copie de la commande `cd` re-stylis√© pour
√™tre compatible avec le 21√®me si√®cle.

√âcrire un programme qui prends un argument et change votre dossier courant pour
le dossier disponnible au bout du path donn√© en argument.

_Bonus:_

- Sans argument renvoi dans votre `home` d'utilisateur

#### pwd : print current working directory

syscall: `getcwd`

```c
#include <unistd.h>

char * getwd(char * buf, size_t size);
```

Note d'ouverture: Sur certains syst√®me, `getcwd` peut √™tre implement√© sans syscall mais
juste une surcouche _wrapper_ au dessus de fonctions plus basiques, c'est un choix de
design.

##### Exercice: WhereAmI

*Objectif:*

- D√©couverte d'un appel syst√®me
- √âcriture d'un programme simple sans arguments
- Manipulation de buffer de texte `(char *)`

√âcrire un programme en C, nomm√© qui affiche le chemin complet vers votre dossier courrant,
inspir√© du programme pwd propos√© dans la suite *coreutils*.

Voici le squelette du programme pour faire cette tache:

```c
#include <stdio.h> // printf
#include <stdlib.h> // size_t
#include <unistd.h> // getwcd.h

int main(void) {
  // On demande un espace contigue de 256 bytes
  // on aurais pu la macro BUFSIZ a la place de 256.
  char buffer[256];

  // Quelle fonction utiliser? Voir les paragrames au dessus
  // Quel paramettre on donne pour recevoir le chemin courant
  get???(???, sizeof(buffer));

  printf("Tu es dans: %s\n", buffer);
  return EXIT_SUCCESS;
}
```

```sh
$ cd /home/axel
$ # On suppose que votre programme est dans votre home
$ ./whereAmI
Vous √™tes dans: /home/axel/
```

*Bonus*:

- G√©rer les cas d'erreurs indiqu√© dans le manuel

<!--
#### ls : list directory content

`ls` permet de lister les fichiers et donc les dossiers courant d'un r√©pertoire
donn√©. C'est une commande extrement pratique.

Une commande plus basique `dir` existe, elle est dans un ensemble de binaires
basiques appell√©es [coreutils](http://www.gnu.org/software/coreutils/dir)
-->

## R√©f√©rences

- [Posix 2018](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/)
- http://www.brendangregg.com/linuxperf.html
- https://linux.die.net/
